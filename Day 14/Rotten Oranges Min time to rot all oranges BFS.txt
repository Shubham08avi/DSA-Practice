Rotten Oranges : Min time to rot all oranges : BFS
------------------------------------------------------------------------------------------------------------------------------------------
Problem Statement: You will be given an m x n grid, where each cell has the following values : 

2  –  represents a rotten orange
1  –  represents a Fresh orange
0  –  represents an Empty Cell
Every minute, if a Fresh Orange is adjacent to a Rotten Orange in 4-direction ( upward, downwards, right, and left ) it becomes Rotten. 

Return the minimum number of minutes required such that none of the cells has a Fresh Orange. If it’s not possible, return -1.

Example 1:
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4

Example 2:
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
------------------------------------------------------------------------------------------------------------------------------------------
Approach 1:

TC: O(N*M*4)
SC: O(N*M)

int orangesRotting(vector<vector<int>>& grid) {
	int n = grid.size();
	int m = grid[0].size();
	int rotten = 0, empty=0;
	vector<vector<int>>visited(n, vector<int>(m, 0));
	queue<pair<int, int>>q;    //{i,j}
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < m; j++) {
			if(grid[i][j] == 0) {
				visited[i][j] = 1;
				++empty;
			} 
			else if(grid[i][j] == 2) {
				q.push({i, j});
				visited[i][j] = 1;
				++rotten;
			}
		}
	}
	int finalRotten = (m*n) - empty;
	if(finalRotten - rotten == 0) return 0;
	if(rotten == 0) return -1;
	int dr[]={-1,0,1,0};
	int dc[]={0,-1,0,1};
	int time=0;
	while(!q.empty()){
		int sz=q.size();
		while(sz--){
			int r=q.front().first;
			int c=q.front().second;
			q.pop();
			for(int i=0; i<4; i++){
				int nr=r+dr[i];
				int nc=c+dc[i];
				if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==1 && visited[nr][nc]==0){
					q.push({nr,nc});
					visited[nr][nc]=1;
					++rotten;
				}
			}
		}
		++time;
	}
	if(finalRotten==rotten) return time-1;
	return -1;
}